<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50 antialiased">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Member Network • Agrovoltaicos sin Fronteras</title>
    <meta name="description"
        content="Interactive network visualization of our community members and their connections.">

    <!-- Critical pre-render script -->
    <script src="auth-preloader.js"></script>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Plus+Jakarta+Sans:wght@500;600;700;800&display=swap"
        rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles.css">

    <!-- External Tailwind Config -->
    <script src="theme.js"></script>

    <!-- Custom CSS -->
    <style>
        body { overflow-y: auto; }
        @media (min-width: 768px) { body { overflow: hidden; } }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; background-clip: content-box; border: 2px solid transparent; }
        .custom-scrollbar:hover::-webkit-scrollbar-thumb { background: #94a3b8; }

        /* Graph Canvas Styles */
        #network-container {
            cursor: grab;
            background-color: #f8fafc;
            background-image: 
                radial-gradient(#e2e8f0 1px, transparent 1px),
                radial-gradient(#f1f5f9 1px, transparent 1px);
            background-size: 40px 40px, 10px 10px;
            background-position: 0 0, 20px 20px;
            touch-action: none;
            overflow: hidden;
        }
        #network-container:active { cursor: grabbing; }

        #networkCanvas {
            transform-origin: 0 0;
            position: absolute; inset: 0; width: 100%; height: 100%;
            pointer-events: none; will-change: transform; transform-style: flat;
        }

        #networkNodes { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }
        .network-connections { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; }

        .network-node {
            position: absolute; transform: translate(-50%, -50%);
            cursor: pointer; pointer-events: auto;
            will-change: transform, z-index;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .member-node { z-index: 20; }
        .group-node { z-index: 5; transition: transform 0.1s linear; }
        
        /* Bubble Mode Styles */
        .bubble-group { 
            border-radius: 50%; 
            opacity: 0.85; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
            transition: all 0.4s ease;
            border: 2px solid rgba(255,255,255,0.5);
        }
        .bubble-group:hover {
            opacity: 1;
            box-shadow: 0 12px 40px rgba(0,0,0,0.12);
        }
        .bubble-member {
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .bubble-member:hover {
            z-index: 1000 !important; /* High Z-Index on hover to ensure tooltip isn't covered */
        }
        
        .network-node.magnified { z-index: 1000 !important; }

        /* Edges */
        .network-edge { fill: none; stroke: #cbd5e1; stroke-width: 1.5px; stroke-opacity: 0.3; }
        .collab-edge { fill: none; stroke: #f59e0b; stroke-width: 2px; stroke-opacity: 0.5; stroke-dasharray: 4; }
        .dock-track { stroke: #cbd5e1; stroke-width: 4px; stroke-linecap: round; opacity: 0.3; }

        /* Table Sorting */
        th[data-sort] { user-select: none; }
        th.sort-asc::after { content: ' ▲'; font-size: 10px; margin-left: 4px; color: #4f46e5; }
        th.sort-desc::after { content: ' ▼'; font-size: 10px; margin-left: 4px; color: #4f46e5; }

        #flash {
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%) translateY(-150%);
            background-color: #0f172a; color: white; padding: 10px 20px; border-radius: 9999px;
            font-weight: 500; font-size: 0.9rem; z-index: 9999; opacity: 0;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
        }
        #flash.visible { transform: translateX(-50%) translateY(0); opacity: 1; }
    </style>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
</head>

<body class="text-slate-800 flex flex-col h-full selection:bg-brand-100 selection:text-brand-900 font-sans bg-gray-50">

    <div id="flash" role="status" aria-live="polite"></div>

    <!-- MAIN CONTENT -->
    <main class="flex-1 relative bg-gray-50 overflow-visible md:overflow-hidden">

        <!-- Loaders -->
        <div id="loadingScreen" class="absolute inset-0 bg-gray-50 z-[60] flex flex-col items-center justify-center transition-opacity duration-500 fixed md:absolute">
            <div class="w-8 h-8 border-2 border-gray-200 border-t-brand-600 rounded-full animate-spin mb-4"></div>
            <span class="text-sm font-medium text-slate-500 animate-pulse">Optimizing Layout...</span>
        </div>

        <div id="signinGate" class="absolute inset-0 bg-gray-50/90 backdrop-blur-sm z-[55] flex items-center justify-center fixed md:absolute" style="display:none;">
            <div class="bg-white rounded-2xl shadow-xl border border-gray-200 p-8 max-w-md text-center mx-4">
                <div class="w-12 h-12 bg-brand-100 rounded-full flex items-center justify-center mx-auto mb-4">
                    <i data-lucide="lock" class="w-6 h-6 text-brand-600"></i>
                </div>
                <h2 class="font-display font-bold text-2xl text-slate-900 mb-2">Member Network</h2>
                <p class="text-slate-500 mb-6 text-sm">Sign in to visualize connections.</p>
                <a href="signin.html" class="inline-flex items-center justify-center px-6 py-2.5 bg-brand-600 hover:bg-brand-700 text-white font-bold rounded-lg transition-colors w-full">Sign In</a>
            </div>
        </div>

        <!-- CONTAINER -->
        <div class="max-w-[1800px] mx-auto w-full h-auto md:h-full flex flex-col md:flex-row gap-4 p-4 md:p-6 relative">

            <!-- LEFT SIDEBAR -->
            <aside class="flex-none w-full md:w-80 bg-white border border-gray-200 rounded-2xl flex flex-col shadow-sm overflow-hidden h-auto md:h-full shrink-0">
                <div class="p-5 border-b border-gray-100 space-y-4">
                    <h2 class="font-display font-bold text-lg text-brand-700 flex items-center gap-2">
                        <i data-lucide="share-2" class="w-5 h-5"></i> Explore Network
                    </h2>

                    <div class="relative z-30">
                        <i data-lucide="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-400"></i>
                        <input type="text" id="searchInput" class="w-full pl-9 pr-4 py-2 bg-gray-50 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-brand-100 outline-none" placeholder="Search people, orgs...">
                    </div>

                    <div class="grid grid-cols-1 gap-3">
                        <div>
                            <label class="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-1.5 block">Group Nodes By</label>
                            <div class="relative">
                                <select id="groupByFilter" class="w-full appearance-none bg-slate-50 border border-gray-200 text-slate-700 text-xs font-bold rounded-lg pl-3 pr-8 py-2.5 focus:ring-2 focus:ring-brand-100 outline-none">
                                    <option value="affiliation">Organization</option>
                                    <option value="country">Country</option>
                                </select>
                                <i data-lucide="chevron-down" class="absolute right-3 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-slate-400 pointer-events-none"></i>
                            </div>
                        </div>

                        <div class="grid grid-cols-2 gap-2">
                            <div class="relative">
                                <select id="eventFilter" class="w-full appearance-none bg-white border border-gray-200 text-slate-700 text-xs font-medium rounded-lg pl-3 pr-8 py-2 focus:ring-2 focus:ring-brand-100 outline-none">
                                    <option value="all">All Events</option>
                                </select>
                                <i data-lucide="chevron-down" class="absolute right-3 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-slate-400 pointer-events-none"></i>
                            </div>
                            <div class="relative">
                                <select id="countryFilter" class="w-full appearance-none bg-white border border-gray-200 text-slate-700 text-xs font-medium rounded-lg pl-3 pr-8 py-2 focus:ring-2 focus:ring-brand-100 outline-none">
                                    <option value="all">All Countries</option>
                                </select>
                                <i data-lucide="chevron-down" class="absolute right-3 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-slate-400 pointer-events-none"></i>
                            </div>
                        </div>
                    </div>

                    <div class="flex flex-wrap gap-2 pt-1">
                        <button class="px-3 py-1 text-[11px] font-bold rounded-full transition-all shadow-sm bg-slate-800 text-white" data-role="all">All Roles</button>
                        <button class="px-3 py-1 text-[11px] font-bold rounded-full transition-all border border-gray-200 text-slate-500 hover:bg-gray-50" data-role="speakers">Speakers</button>
                        <button class="px-3 py-1 text-[11px] font-bold rounded-full transition-all border border-gray-200 text-slate-500 hover:bg-gray-50" data-role="organizers">Hosts</button>
                    </div>
                </div>

                <div class="flex-1 overflow-y-auto custom-scrollbar p-5 min-h-[200px] md:min-h-0">
                    <div class="flex items-center justify-between mb-2">
                        <label class="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Interests & Tags</label>
                        <button id="clearFiltersBtn" class="text-[10px] font-bold text-brand-600 hover:underline">Clear</button>
                    </div>
                    <div id="selectedTagsContainer" class="flex flex-wrap gap-1.5 mb-3 empty:hidden"></div>
                    <div id="tagFilters" class="space-y-0.5"></div>
                </div>

                <div class="p-4 bg-slate-50 border-t border-gray-200 mt-auto">
                    <div class="grid grid-cols-2 gap-2">
                        <div class="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm text-center">
                            <span id="statMembers" class="block text-xl font-display font-bold text-slate-800 leading-none mb-0.5">0</span>
                            <span class="text-[9px] font-bold text-slate-400 uppercase tracking-wider">Members</span>
                        </div>
                        <div class="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm text-center">
                            <span id="statConnections" class="block text-xl font-display font-bold text-brand-600 leading-none mb-0.5">0</span>
                            <span class="text-[9px] font-bold text-slate-400 uppercase tracking-wider">Connections</span>
                        </div>
                        <div class="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm text-center">
                            <span id="statOrgs" class="block text-xl font-display font-bold text-slate-800 leading-none mb-0.5">0</span>
                            <span class="text-[9px] font-bold text-slate-400 uppercase tracking-wider">Orgs</span>
                        </div>
                        <div class="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm text-center">
                            <span id="statEvents" class="block text-xl font-display font-bold text-slate-800 leading-none mb-0.5">0</span>
                            <span class="text-[9px] font-bold text-slate-400 uppercase tracking-wider">Events</span>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- RIGHT COLUMN -->
            <div class="flex-1 flex flex-col gap-4 min-w-0 h-auto md:h-full">

                <!-- VISUALIZATION -->
                <section id="network-container" class="md:flex-[2] bg-white border border-gray-200 rounded-2xl shadow-sm relative overflow-hidden h-[500px] md:h-auto shrink-0 group">
                    <div id="networkCanvas">
                        <svg class="network-connections" id="networkConnections"></svg>
                        <div id="networkNodes"></div>
                    </div>

                    <!-- Top Left Controls -->
                    <div class="absolute top-4 left-4 flex gap-2 z-40">
                         <button id="viewToggleBtn" class="flex items-center gap-2 px-3 py-1.5 bg-white text-xs font-bold text-slate-600 rounded-lg shadow-sm border border-gray-200 hover:border-brand-300 hover:text-brand-700 transition-all">
                            <i data-lucide="layout-grid" class="w-4 h-4 text-brand-500"></i>
                            <span id="viewModeText">Switch to Bubbles</span>
                        </button>
                    </div>

                    <!-- Top Right Controls -->
                    <div class="absolute top-4 right-4 flex gap-2 z-40">
                        <div class="flex items-center gap-2 bg-white/90 backdrop-blur border border-gray-200 rounded-lg px-3 py-1.5 shadow-sm text-xs text-slate-600 font-medium">
                            <i data-lucide="scan-search" class="w-4 h-4 text-brand-500"></i>
                            <span>Hover to Magnify</span>
                        </div>
                        <button id="resetViewBtn" class="px-3 py-1.5 bg-white text-xs font-bold text-slate-600 rounded-lg shadow-sm border border-gray-200 hover:border-brand-300 hover:text-brand-700 transition-all">
                            Reset View
                        </button>
                    </div>

                    <div id="legendContainer" class="absolute bottom-4 left-4 z-40 pointer-events-none">
                        <!-- Content populated by script based on mode -->
                    </div>
                </section>

                <!-- TABLE -->
                <section class="md:flex-1 bg-white border border-gray-200 rounded-2xl shadow-sm flex flex-col overflow-hidden h-[500px] md:h-auto shrink-0">
                    <div class="overflow-auto custom-scrollbar flex-1">
                        <table class="w-full text-left border-collapse">
                            <thead class="bg-gray-50 sticky top-0 z-20 shadow-sm">
                                <tr>
                                    <th class="py-3 px-6 text-[11px] font-bold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100 transition-colors" data-sort="name">Name</th>
                                    <th class="py-3 px-6 text-[11px] font-bold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100 transition-colors" data-sort="affiliation">Affiliation / Institution</th>
                                    <th class="py-3 px-6 text-[11px] font-bold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100 transition-colors w-1/3 hidden lg:table-cell" data-sort="interests">Interests</th>
                                    <th class="py-3 px-6 text-[11px] font-bold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100 transition-colors hidden sm:table-cell" data-sort="country">Country</th>
                                    <th class="py-3 px-6 text-[11px] font-bold text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100 transition-colors text-right" data-sort="connections">Connections</th>
                                </tr>
                            </thead>
                            <tbody id="members-table-body" class="divide-y divide-gray-100 text-sm text-slate-700"></tbody>
                        </table>
                    </div>
                </section>
            </div>
        </div>
    </main>

    <!-- LOGIC -->
    <script type="module">
        import { renderLayout } from './layout.js';
        import { supabase, authState, initAuth, signOut } from './auth.js';
        import { initSharedUI, renderHeader, applyI18n, tr, $, $$, show, hide, getAvatarUrl } from './ui.js';
        import { initProfileModal, openProfileModal } from './clickprofile.js';

        renderLayout('network');

        const state = {
            members: [], profileById: new Map(), isSpeaker: new Set(), speakersByProfileId: new Map(),
            eventsById: new Map(), orgIndex: new Map(), tagIndex: new Map(), tagCounts: new Map(),
            allCanonicalToDisplay: new Map(), connections: [], nodes: new Map(),
            positions: new Map(), panOffset: { x: 0, y: 0 }, zoom: 1,
            sort: { key: "connections", dir: "desc" }, 
            roleFilter: "all", eventFilterId: "all", countryFilterId: "all",
            groupBy: "affiliation", 
            searchQuery: "", selectedTags: new Set(),
            lang: localStorage.getItem("lang") || "en",
            isDragging: false,
            viewMode: 'network',
            currentGroupBaseScale: 1,
            countries: {
                "US": "United States", "MX": "Mexico", "CA": "Canada", "CO": "Colombia", "BR": "Brazil", 
                "CL": "Chile", "AR": "Argentina", "PE": "Peru", "ES": "Spain", "FR": "France", "DE": "Germany",
                "BE": "Belgium", "NL": "Netherlands", "IT": "Italy", "UK": "UK", "GB": "UK",
                "IN": "India", "CN": "China", "AU": "Australia"
            }
        };

        const t = { en: { auth: { signin: "Sign in", signout: "Sign out" } }, es: { auth: { signin: "Ingresar", signout: "Salir" } } };

        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const highlight = (text, q) => { if (!q || !text) return text || ""; try { const rx = new RegExp(`(${q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, "ig"); return (text + "").replace(rx, '<span class="bg-yellow-100 text-yellow-800 px-0.5 rounded">$1</span>'); } catch { return text; } };
        const debounce = (fn, ms = 200) => { let t = null; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            const h = Math.abs(hash) % 360;
            return `hsl(${h}, 55%, 75%)`;
        }
        
        function stringToColorDark(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            const h = Math.abs(hash) % 360;
            return `hsl(${h}, 45%, 35%)`;
        }

        async function loadNetworkData() {
            const [profiles, speakers, events] = await Promise.all([
                supabase.from('profiles').select('id, full_name, avatar_url, affiliation, fields_of_study, country, role, collaborators').order('full_name'),
                supabase.from('event_speakers').select('event_id, profile_id'),
                supabase.from('events').select('id, title_en, title_es, start_time, topic_tags').order('start_time', { ascending: false })
            ]);

            state.members = profiles.data || [];
            state.members.forEach(m => state.profileById.set(m.id, m));
            (events.data || []).forEach(e => state.eventsById.set(e.id, e));

            const eventSelect = $('#eventFilter');
            eventSelect.innerHTML = '<option value="all">All Events</option>';
            state.eventsById.forEach(e => eventSelect.add(new Option(new Date(e.start_time).toLocaleDateString() + ' - ' + e.title_en, e.id)));

            const countrySelect = $('#countryFilter');
            countrySelect.innerHTML = '<option value="all">All Countries</option>';
            const uniqueCountries = new Set(state.members.map(m => m.country).filter(Boolean));
            Array.from(uniqueCountries).sort().forEach(code => {
                const name = state.countries[code] || code;
                countrySelect.add(new Option(`${name} (${code})`, code));
            });

            (speakers.data || []).forEach(s => {
                if (!s.profile_id) return;
                state.isSpeaker.add(s.profile_id);
                if (!state.speakersByProfileId.has(s.profile_id)) state.speakersByProfileId.set(s.profile_id, new Set());
                state.speakersByProfileId.get(s.profile_id).add(s.event_id);
            });

            state.members.forEach(m => {
                const org = m.affiliation?.trim();
                if (org) { if (!state.orgIndex.has(org)) state.orgIndex.set(org, new Set()); state.orgIndex.get(org).add(m.id); }

                const rawTags = (m.fields_of_study || "").split(",").map(s => s.trim()).filter(Boolean);
                if (state.speakersByProfileId.has(m.id)) {
                    state.speakersByProfileId.get(m.id).forEach(eid => {
                        const ev = state.eventsById.get(eid);
                        if (ev?.topic_tags) rawTags.push(...ev.topic_tags);
                    });
                }
                const unique = new Set(rawTags.map(t => t.toLowerCase()));
                unique.forEach(u => {
                    const display = rawTags.find(r => r.toLowerCase() === u) || u;
                    if (!state.tagIndex.has(u)) state.tagIndex.set(u, new Set());
                    state.tagIndex.get(u).add(m.id);
                    state.allCanonicalToDisplay.set(u, display);
                    state.tagCounts.set(u, (state.tagCounts.get(u) || 0) + 1);
                });
            });

            const conns = []; const processed = new Set();
            state.members.forEach(m => {
                if(m.collaborators && Array.isArray(m.collaborators)) {
                    m.collaborators.forEach(targetId => {
                        const key = [m.id, targetId].sort().join('-');
                        if(!processed.has(key) && state.profileById.has(targetId)) {
                            conns.push({ source: m.id, target: targetId, type: 'collab' });
                            processed.add(key);
                        }
                    });
                }
            });
            state.connections = conns;

            $('#statMembers').innerText = state.members.length;
            $('#statConnections').innerText = conns.length + state.members.filter(m=>m.affiliation).length; 
            $('#statOrgs').innerText = state.orgIndex.size;
            $('#statEvents').innerText = state.eventsById.size;

            populateTagFilters();
            onFiltersChanged();
        }

        function populateTagFilters() {
            const c = $('#tagFilters'); c.innerHTML = '';
            Array.from(state.tagCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 50).forEach(([tag, count]) => {
                const row = document.createElement('div');
                row.className = 'flex items-center justify-between px-2 py-1 hover:bg-gray-50 rounded cursor-pointer group';
                const isSel = state.selectedTags.has(tag);
                row.innerHTML = `<div class="flex items-center gap-2"><div class="w-3 h-3 rounded-sm border ${isSel ? 'bg-brand-500 border-brand-500' : 'border-gray-300'} flex items-center justify-center">${isSel ? '<svg width="8" height="8" viewBox="0 0 24 24" stroke="white" stroke-width="4" fill="none"><polyline points="20 6 9 17 4 12"/></svg>' : ''}</div><span class="text-xs text-slate-600">${state.allCanonicalToDisplay.get(tag)}</span></div><span class="text-[10px] text-slate-300 font-bold">${count}</span>`;
                row.onclick = () => { if (isSel) state.selectedTags.delete(tag); else state.selectedTags.add(tag); onFiltersChanged(); };
                c.appendChild(row);
            });
            const selC = $('#selectedTagsContainer'); selC.innerHTML = '';
            state.selectedTags.forEach(t => selC.insertAdjacentHTML('beforeend', `<span class="px-2 py-0.5 bg-brand-50 text-brand-700 border border-brand-100 rounded text-[10px] font-bold flex items-center gap-1">${state.allCanonicalToDisplay.get(t)} <button onclick="document.dispatchEvent(new CustomEvent('remTag',{detail:'${t}'}))">×</button></span>`));
        }
        document.addEventListener('remTag', e => { state.selectedTags.delete(e.detail); onFiltersChanged(); });

        function calculatePositions(members) {
            const byGroup = new Map();
            const dockMembers = [];
            const dockKeys = ["Unaffiliated", "Independent", "Consultant", "Unknown Location", "Unknown", ""];

            members.forEach(m => {
                let key = "";
                if (state.groupBy === 'country') {
                    key = m.country ? (state.countries[m.country] || m.country) : "Unknown";
                } else {
                    key = m.affiliation?.trim() || "Unaffiliated";
                }
                
                const isDockKey = dockKeys.some(k => k.toLowerCase() === key.toLowerCase());

                if (state.viewMode === 'bubble') {
                    if (isDockKey) {
                        return;
                    }
                    if (!byGroup.has(key)) byGroup.set(key, []);
                    byGroup.get(key).push(m);
                } else {
                    if (isDockKey) {
                        dockMembers.push(m);
                    } else {
                        if (!byGroup.has(key)) byGroup.set(key, []);
                        byGroup.get(key).push(m);
                    }
                }
            });

            if (state.viewMode === 'bubble') {
                const container = $('#network-container');
                const containerWidth = container.offsetWidth || 800;
                const containerHeight = container.offsetHeight || 600;
                
                const clusters = [];
                let totalMemberCount = 0;
                
                for (const [name, list] of byGroup.entries()) {
                    const count = list.length;
                    totalMemberCount += count;
                    clusters.push({ name, list, count });
                }
                
                clusters.sort((a, b) => b.count - a.count);
                
                const pos = new Map();
                
                const availableArea = containerWidth * containerHeight * 0.85;
                const areaPerMember = availableArea / Math.max(totalMemberCount, 1);
                const memberRadius = Math.max(18, Math.min(30, Math.sqrt(areaPerMember / Math.PI) * 0.4));
                
                const packedClusters = [];
                
                clusters.forEach((cluster) => {
                    const count = cluster.count;
                    const innerArea = count * Math.PI * (memberRadius + 8) * (memberRadius + 8) * 2.5;
                    const clusterRadius = Math.max(60, Math.sqrt(innerArea / Math.PI));
                    packedClusters.push({
                        ...cluster,
                        radius: clusterRadius,
                        x: 0,
                        y: 0
                    });
                });
                
                if (packedClusters.length > 0) {
                    packedClusters[0].x = 0;
                    packedClusters[0].y = 0;
                    
                    for (let i = 1; i < packedClusters.length; i++) {
                        const current = packedClusters[i];
                        let bestAngle = 0;
                        let bestDistance = Infinity;
                        let bestX = 0;
                        let bestY = 0;
                        
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 36) {
                            for (let dist = 0; dist < 3000; dist += 20) {
                                const testX = Math.cos(angle) * dist;
                                const testY = Math.sin(angle) * dist;
                                
                                let valid = true;
                                for (let j = 0; j < i; j++) {
                                    const other = packedClusters[j];
                                    const dx = testX - other.x;
                                    const dy = testY - other.y;
                                    const minDist = current.radius + other.radius + 30;
                                    if (dx * dx + dy * dy < minDist * minDist) {
                                        valid = false;
                                        break;
                                    }
                                }
                                
                                if (valid && dist < bestDistance) {
                                    bestDistance = dist;
                                    bestX = testX;
                                    bestY = testY;
                                    bestAngle = angle;
                                }
                            }
                        }
                        
                        current.x = bestX;
                        current.y = bestY;
                    }
                }
                
                packedClusters.forEach(cluster => {
                    pos.set(`group-${cluster.name}`, { 
                        x: cluster.x, 
                        y: cluster.y, 
                        r: cluster.radius 
                    });
                    
                    const memberCount = cluster.list.length;
                    if (memberCount === 1) {
                        pos.set(cluster.list[0].id, {
                            x: cluster.x,
                            y: cluster.y
                        });
                    } else {
                        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                        const maxRadius = cluster.radius - memberRadius - 15;
                        
                        cluster.list.forEach((m, idx) => {
                            const normalizedIndex = idx / memberCount;
                            const spiralRadius = maxRadius * Math.sqrt(normalizedIndex);
                            const angle = idx * goldenAngle;
                            
                            pos.set(m.id, {
                                x: cluster.x + Math.cos(angle) * spiralRadius,
                                y: cluster.y + Math.sin(angle) * spiralRadius
                            });
                        });
                    }
                });
                
                return { 
                    pos, 
                    clusters: packedClusters, 
                    mode: 'bubble',
                    memberRadius 
                };
            }

            const clusters = [];
            let totalStageArea = 0;
            
            for (const [name, list] of byGroup.entries()) {
                const count = list.length;
                const ringR = Math.max(160, (count * 55) / (2 * Math.PI));
                const size = (ringR * 2) + 200; 
                totalStageArea += size * size;
                clusters.push({ name, list, ringR, size });
            }
            clusters.sort((a, b) => b.list.length - a.list.length);

            const aspectRatio = 3.5; 
            const TARGET_ROW_WIDTH = Math.sqrt(totalStageArea * aspectRatio) + 500;
            const CLUSTER_GAP = 220;

            const pos = new Map();
            let rowX = 0, rowY = 0, rowItems = [], maxH = 0;
            let minStageX = 0;

            const flushRow = () => {
                const rowTotalWidth = rowX - CLUSTER_GAP;
                let startX = -(rowTotalWidth / 2);
                if (startX < minStageX) minStageX = startX; 

                rowItems.forEach(c => {
                    const cx = startX + (c.size / 2);
                    const cy = rowY + (c.size / 2);
                    pos.set(`group-${c.name}`, { x: cx, y: cy });
                    if (c.list.length > 0) {
                        const step = (Math.PI * 2) / c.list.length;
                        c.list.forEach((m, i) => {
                            const angle = step * i;
                            const r = c.ringR + (i % 2 === 0 ? 0 : 50); 
                            pos.set(m.id, { x: cx + Math.cos(angle) * r, y: cy + Math.sin(angle) * r });
                        });
                    }
                    startX += c.size + CLUSTER_GAP;
                });
                rowY += maxH + CLUSTER_GAP;
                rowX = 0; rowItems = []; maxH = 0;
            };

            clusters.forEach(c => {
                if (rowX + c.size > TARGET_ROW_WIDTH && rowItems.length > 0) flushRow();
                rowItems.push(c);
                rowX += c.size + CLUSTER_GAP;
                if (c.size > maxH) maxH = c.size;
            });
            if (rowItems.length > 0) flushRow();
            
            const stageHeight = rowY;
            for (const [k, p] of pos.entries()) p.y -= stageHeight / 2;

            dockMembers.sort((a,b) => (a.full_name||"").localeCompare(b.full_name||""));
            const DOCK_X = (minStageX || -900) - 800; 
            const DOCK_ITEM_H = 40; 
            const totalDockH = dockMembers.length * DOCK_ITEM_H;
            
            dockMembers.forEach((m, i) => {
                pos.set(m.id, { x: DOCK_X, y: (i * DOCK_ITEM_H) - (totalDockH / 2) });
            });

            return { pos, clusters, dockX: DOCK_X, dockYMin: -(totalDockH/2), dockYMax: (totalDockH/2), mode: 'network' };
        }

        function renderGraph(members) {
            const c = $('#network-container');
            if (c.offsetWidth === 0) return;
            
            const layout = calculatePositions(members);
            state.positions = layout.pos;

            const svg = $('#networkConnections'); 
            const nodes = $('#networkNodes');
            svg.innerHTML = ''; 
            nodes.innerHTML = '';

            if (state.viewMode === 'bubble') {
                $('#legendContainer').innerHTML = `
                   <div class="flex items-center gap-3 bg-white/90 backdrop-blur p-3 rounded-xl border border-gray-200 shadow-sm text-[11px] font-medium text-slate-600">
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded-full bg-gradient-to-br from-slate-200 to-slate-300 border-2 border-white shadow-sm"></div>
                            <span>Organization</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded-full bg-white border-2 border-brand-400 shadow-sm"></div>
                            <span>Member</span>
                        </div>
                    </div>`;

                const memberRadius = layout.memberRadius || 20;

                // 1. Render Group Backgrounds (Circles)
                layout.clusters.forEach(cluster => {
                    const p = state.positions.get(`group-${cluster.name}`);
                    if (!p) return;
                    
                    const el = document.createElement('div');
                    el.className = 'network-node group-node bubble-group';
                    el.dataset.x = p.x; 
                    el.dataset.y = p.y; 
                    el.dataset.type = 'group';
                    
                    const diameter = p.r * 2;
                    el.style.width = `${diameter}px`; 
                    el.style.height = `${diameter}px`;
                    el.style.backgroundColor = stringToColor(cluster.name);
                    el.style.transform = `translate(-50%, -50%) translate(${p.x}px, ${p.y}px)`;
                    
                    el.onclick = (e) => { 
                        e.stopPropagation(); 
                        $('#searchInput').value = cluster.name; 
                        onFiltersChanged(); 
                    };
                    nodes.appendChild(el);
                });

                // 2. Render Members
                members.forEach(m => {
                    const p = state.positions.get(m.id);
                    if (!p) return;

                    const displayName = m.full_name || 'Member';
                    const el = document.createElement('div');
                    // Added group/bub for hover state logic
                    el.className = 'network-node member-node bubble-member group/bub';
                    el.dataset.x = p.x; 
                    el.dataset.y = p.y;
                    el.style.transform = `translate(-50%, -50%) translate(${p.x}px, ${p.y}px)`;
                    
                    const size = memberRadius * 2;
                    
                    // STRUCTURE CHANGE: Tooltip moved OUTSIDE the overflow-hidden div, but inside the main relative node
                    el.innerHTML = `
                        <div class="rounded-full bg-white flex items-center justify-center shadow-md border-2 border-white hover:border-brand-500 hover:scale-125 transition-all duration-200 overflow-hidden cursor-pointer relative" style="width: ${size}px; height: ${size}px;">
                             ${m.avatar_url ? `<img src="${m.avatar_url}" class="w-full h-full object-cover">` : `<span class="text-xs font-bold text-brand-600">${displayName[0]}</span>`}
                        </div>
                        
                        <!-- Tooltip: Absolute positioned relative to the parent node wrapper, outside the clipped image circle -->
                        <div class="absolute top-full mt-2 left-1/2 -translate-x-1/2 whitespace-nowrap bg-slate-900/90 backdrop-blur text-white text-[11px] py-1.5 px-3 rounded-lg opacity-0 group-hover/bub:opacity-100 pointer-events-none transition-opacity duration-200 z-[100] shadow-xl border border-white/10">
                            <div class="font-bold">${displayName}</div>
                            ${m.affiliation ? `<div class="text-slate-300 text-[9px] font-medium">${m.affiliation}</div>` : ''}
                            <!-- Little arrow pointing up -->
                            <div class="absolute -top-1 left-1/2 -translate-x-1/2 border-l-4 border-r-4 border-b-4 border-l-transparent border-r-transparent border-b-slate-900/90"></div>
                        </div>
                    `;
                    
                    if (m.avatar_url) getAvatarUrl(m.avatar_url).then(u => { if (u) { const img = el.querySelector('img'); if(img) img.src = u; }});

                    el.onclick = (e) => {
                        e.stopPropagation();
                        openProfileModal(m, state.allCanonicalToDisplay, state.tagIndex);
                    };
                    nodes.appendChild(el);
                });

                // 3. Render Group Labels (Overlay)
                layout.clusters.forEach(cluster => {
                    const p = state.positions.get(`group-${cluster.name}`);
                    if (!p) return;

                    const label = document.createElement('div');
                    label.className = 'network-node pointer-events-none z-30';
                    label.dataset.x = p.x;
                    label.dataset.y = p.y - p.r; // Position at the top edge
                    label.dataset.type = 'group-label';
                    
                    // Position at top edge of circle
                    label.style.transform = `translate(-50%, -50%) translate(${p.x}px, ${p.y - p.r}px)`;

                    label.innerHTML = `
                        <div class="flex flex-col items-center">
                            <span class="px-3 py-1 bg-white/95 backdrop-blur shadow-md border border-gray-200 rounded-full text-[11px] font-bold text-slate-700 whitespace-nowrap ring-1 ring-black/5" style="max-width: 250px; overflow: hidden; text-overflow: ellipsis;">
                                ${cluster.name}
                            </span>
                            <span class="mt-0.5 text-[9px] font-bold text-slate-500 bg-white/75 px-1.5 rounded-full shadow-sm border border-gray-100">
                                ${cluster.count}
                            </span>
                        </div>
                    `;
                    nodes.appendChild(label);
                });
                
                if (window.lucide) window.lucide.createIcons();
                fitGraph();
                return;
            }

             $('#legendContainer').innerHTML = `
                <div class="flex flex-col gap-1.5 bg-white/80 backdrop-blur p-2 rounded-lg border border-gray-100 shadow-sm text-[10px] font-medium text-slate-600">
                    <div class="flex items-center gap-2">
                        <div class="w-6 h-0.5 bg-slate-300 opacity-50"></div>
                        <span>Affiliation / Group</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-6 h-0.5 bg-amber-500 opacity-60"></div>
                        <span>Collaborator</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-1 h-4 bg-slate-300 opacity-50 rounded-full mx-2"></div>
                        <span>Drag vertical track</span>
                    </div>
                </div>`;

            let paths = '';
            
            if (layout.dockYMin !== undefined && layout.dockYMax !== undefined) {
                 const pad = 50;
                 paths += `<path d="M ${layout.dockX + 120} ${layout.dockYMin - pad} L ${layout.dockX + 120} ${layout.dockYMax + pad}" class="dock-track" />`;
            }

            members.forEach(m => {
                const mp = state.positions.get(m.id);
                let groupKey = "";
                 if (state.groupBy === 'country') {
                    groupKey = m.country ? (state.countries[m.country] || m.country) : "Unknown";
                } else {
                    groupKey = m.affiliation?.trim() || "Unaffiliated";
                }
                const gp = state.positions.get(`group-${groupKey}`);

                if (mp && gp) {
                    paths += `<path d="M ${mp.x} ${mp.y} L ${gp.x} ${gp.y}" class="network-edge"/>`;
                }
            });

            state.connections.forEach(conn => {
                const p1 = state.positions.get(conn.source);
                const p2 = state.positions.get(conn.target);
                if (p1 && p2) {
                     const cx = (p1.x + p2.x) / 2;
                     const cy = (p1.y + p2.y) / 2 - 25; 
                     paths += `<path d="M ${p1.x} ${p1.y} Q ${cx} ${cy} ${p2.x} ${p2.y}" class="collab-edge"/>`;
                }
            });

            svg.innerHTML = paths;

            layout.clusters.forEach(cluster => {
                const p = state.positions.get(`group-${cluster.name}`);
                if (!p) return;
                
                const count = cluster.list.length;
                const isCountry = state.groupBy === 'country';
                const icon = isCountry ? 'globe-2' : 'building-2';
                const colorClass = isCountry ? 'bg-indigo-900 ring-indigo-100' : 'bg-slate-900 ring-white';

                const el = document.createElement('div'); 
                el.className = 'network-node group-node';
                el.dataset.x = p.x; 
                el.dataset.y = p.y; 
                el.dataset.type = 'group';
                el.style.transform = `translate(-50%, -50%) translate(${p.x}px, ${p.y}px)`;
                
                el.innerHTML = `
                    <div class="flex flex-col items-center gap-2 group/center transition-all">
                        <div class="relative">
                            <div class="w-16 h-16 ${colorClass} rounded-2xl flex items-center justify-center shadow-lg ring-4 relative z-10">
                                <i data-lucide="${icon}" class="text-white w-8 h-8"></i>
                            </div>
                            <div class="absolute -top-2 -right-2 w-7 h-7 bg-brand-500 rounded-full flex items-center justify-center text-white text-xs font-bold border-2 border-white shadow-sm z-20">
                                ${count}
                            </div>
                        </div>
                        <div class="px-4 py-2 bg-white border border-slate-200 rounded-xl shadow-sm max-w-[280px] text-center relative z-20">
                             <span class="text-sm font-black text-slate-800 uppercase tracking-tight leading-none block">${cluster.name}</span>
                        </div>
                    </div>
                `;
                el.onclick = (e) => { e.stopPropagation(); $('#searchInput').value = cluster.name; onFiltersChanged(); };
                nodes.appendChild(el);
            });

            members.forEach(m => {
                const p = state.positions.get(m.id);
                if (!p) return;

                const displayName = m.full_name || 'Member';
                const el = document.createElement('div'); 
                el.className = 'network-node member-node';
                el.dataset.x = p.x; 
                el.dataset.y = p.y;
                el.style.transform = `translate(-50%, -50%) translate(${p.x}px, ${p.y}px)`;
                
                el.innerHTML = `
            <div class="node-pill flex items-center gap-3 pl-1 pr-4 py-1 bg-white border border-gray-200 rounded-full shadow-sm transition-all duration-200 min-w-[150px] group-hover:border-brand-400 group-hover:shadow-md group-hover:ring-2 group-hover:ring-brand-100">
                <div class="node-avatar w-8 h-8 rounded-full bg-brand-50 text-brand-600 flex items-center justify-center text-xs font-bold overflow-hidden shrink-0 ring-2 ring-white shadow-sm">
                    ${displayName[0].toUpperCase()}
                </div>
                <div class="min-w-0">
                    <span class="node-name text-xs font-bold text-slate-700 leading-tight block truncate">${displayName}</span>
                    <span class="node-affiliation text-[9px] text-slate-400 leading-tight truncate max-w-[120px] block mt-0.5">${m.affiliation || '—'}</span>
                </div>
            </div>`;
                if (m.avatar_url) getAvatarUrl(m.avatar_url).then(u => { if (u) el.querySelector('.node-avatar').innerHTML = `<img src="${u}" class="w-full h-full object-cover">` });

                el.onclick = (e) => {
                    e.stopPropagation();
                    openProfileModal(m, state.allCanonicalToDisplay, state.tagIndex);
                };
                nodes.appendChild(el);
            });

            if (window.lucide) window.lucide.createIcons();
            fitGraph();
        }

        function fitGraph() {
            const pts = Array.from(state.positions.values()).filter(p => !isNaN(p.x) && !isNaN(p.y));
            if (!pts.length) return;
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            pts.forEach(p => { 
                const r = p.r || 0;
                if (p.x - r < minX) minX = p.x - r; 
                if (p.x + r > maxX) maxX = p.x + r; 
                if (p.y - r < minY) minY = p.y - r; 
                if (p.y + r > maxY) maxY = p.y + r; 
            });

            const padding = state.viewMode === 'bubble' ? 100 : 500;
            const w = maxX - minX + padding;
            const h = maxY - minY + padding;
            const c = $('#network-container');
            const scale = Math.min(c.offsetWidth / w, c.offsetHeight / h, state.viewMode === 'bubble' ? 1.5 : 1.2);

            if (isFinite(scale) && scale > 0) {
                state.zoom = scale;
                state.panOffset.x = (c.offsetWidth / 2) - ((minX + maxX) / 2) * scale;
                state.panOffset.y = (c.offsetHeight / 2) - ((minY + maxY) / 2) * scale;
                updateTransform();
            }
        }

        function getGroupBaseScale() {
            if (state.viewMode === 'bubble') return 1;
            const inverseScale = 1 / Math.max(0.2, state.zoom);
            return clamp(inverseScale * 0.7, 1, 3.5);
        }

        function updateTransform() {
            $('#networkCanvas').style.transform = `translate(${state.panOffset.x}px, ${state.panOffset.y}px) scale(${state.zoom})`;

            state.currentGroupBaseScale = getGroupBaseScale();

            if (state.viewMode !== 'bubble') {
                document.querySelectorAll('.group-node').forEach(node => {
                    if (!node.classList.contains('magnified')) {
                        const wx = parseFloat(node.dataset.x);
                        const wy = parseFloat(node.dataset.y);
                        node.style.transform = `translate(-50%, -50%) translate(${wx}px, ${wy}px) scale(${state.currentGroupBaseScale})`;
                    }
                });
            }
        }

        function applyMagnification(mouseX, mouseY) {
            if (state.isDragging) return;
            
            const radius = 250; 
            const maxScale = state.viewMode === 'bubble' ? 2.0 : 4.0;
            let nearestNode = null; 
            let minDist = Infinity;

            const groupBaseScale = getGroupBaseScale();

            document.querySelectorAll('.network-node').forEach(node => {
                // Skip magnification for label overlays
                if (node.dataset.type === 'group-label') return;

                const wx = parseFloat(node.dataset.x);
                const wy = parseFloat(node.dataset.y);
                const isGroup = node.dataset.type === 'group';
                
                if (state.viewMode === 'bubble' && isGroup) {
                    return;
                }

                const screenX = (wx * state.zoom) + state.panOffset.x;
                const screenY = (wy * state.zoom) + state.panOffset.y;
                const dx = screenX - mouseX;
                const dy = screenY - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                let baseScale = 1;
                if (state.viewMode !== 'bubble' && isGroup) {
                    baseScale = groupBaseScale;
                }
                
                if (dist < radius) {
                    const factor = 1 - (dist / radius);
                    const ease = factor * factor * factor;
                    const magnifyAmount = ease * (maxScale - 1);
                    const finalScale = baseScale + magnifyAmount;
                    
                    node.style.transform = `translate(-50%, -50%) translate(${wx}px, ${wy}px) scale(${finalScale})`;
                    
                    if (dist < minDist) { 
                        minDist = dist; 
                        nearestNode = node; 
                    }
                } else {
                    node.style.transform = `translate(-50%, -50%) translate(${wx}px, ${wy}px) scale(${baseScale})`;
                }
                node.classList.remove('magnified');
            });
            
            if (nearestNode && minDist < 100) {
                nearestNode.classList.add('magnified');
            }
        }

        function resetMagnification() {
            const groupBaseScale = getGroupBaseScale();
            
            document.querySelectorAll('.network-node').forEach(node => {
                if (state.viewMode === 'bubble' && node.classList.contains('bubble-group')) {
                    return;
                }
                // Skip labels
                if (node.dataset.type === 'group-label') return;
                
                const wx = parseFloat(node.dataset.x);
                const wy = parseFloat(node.dataset.y);
                const isGroup = node.dataset.type === 'group';
                
                let baseScale = 1;
                if (state.viewMode !== 'bubble' && isGroup) {
                    baseScale = groupBaseScale;
                }
                
                node.style.transform = `translate(-50%, -50%) translate(${wx}px, ${wy}px) scale(${baseScale})`;
                node.classList.remove('magnified');
            });
        }

        function getFiltered() {
            let ids = new Set(state.members.map(m => m.id));
            
            if (state.roleFilter === 'speakers') ids = new Set([...ids].filter(id => state.isSpeaker.has(id)));
            else if (state.roleFilter === 'organizers') ids = new Set([...ids].filter(id => ['organizer', 'admin'].includes(state.profileById.get(id).role)));

            if (state.eventFilterId !== 'all') ids = new Set([...ids].filter(id => state.speakersByProfileId.get(id)?.has(state.eventFilterId)));
            if (state.countryFilterId !== 'all') ids = new Set([...ids].filter(id => state.profileById.get(id).country === state.countryFilterId));

            if (state.searchQuery) {
                const q = state.searchQuery.toLowerCase();
                ids = new Set([...ids].filter(id => {
                    const m = state.profileById.get(id);
                    return (m.full_name||"").toLowerCase().includes(q) || (m.affiliation||"").toLowerCase().includes(q);
                }));
            }

            if (state.selectedTags.size > 0) {
                ids = new Set([...ids].filter(id => {
                    for (const t of state.selectedTags) if (state.tagIndex.get(t)?.has(id)) return true;
                    return false;
                }));
            }

            const res = [...ids].map(id => state.profileById.get(id));
            const k = state.sort.key; const d = state.sort.dir === 'asc' ? 1 : -1;
            
            res.sort((a, b) => {
                if (k === 'connections') {
                     const ca = state.connections.filter(c => c.source === a.id || c.target === a.id).length;
                     const cb = state.connections.filter(c => c.source === b.id || c.target === b.id).length;
                     return (ca - cb) * d;
                }
                return (a[k === 'name' ? 'full_name' : k] || "").localeCompare(b[k === 'name' ? 'full_name' : k] || "") * d;
            });
            return res;
        }

        function renderTable(list) {
            $('#members-table-body').innerHTML = list.map(m => {
                const displayName = m.full_name || 'Member';
                const countryName = m.country ? (state.countries[m.country] || m.country) : '—';
                const connCount = state.connections.filter(c => c.source === m.id || c.target === m.id).length;

                return `<tr class="hover:bg-gray-50 cursor-pointer transition-colors" onclick="document.dispatchEvent(new CustomEvent('openProfile',{detail:'${m.id}'}))">
              <td class="py-2.5 px-6 border-b border-gray-50 font-medium text-slate-900">
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-full bg-slate-100 flex items-center justify-center overflow-hidden text-xs text-slate-500 font-bold shrink-0 ring-1 ring-gray-100">
                        ${m.avatar_url ? `<img src="${m.avatar_url}" class="w-full h-full object-cover">` : displayName[0].toUpperCase()}
                    </div>
                    <span>${highlight(displayName, state.searchQuery)}</span>
                </div>
              </td>
              <td class="py-2.5 px-6 border-b border-gray-50 text-slate-500">${highlight(m.affiliation || '—', state.searchQuery)}</td>
              <td class="py-2.5 px-6 border-b border-gray-50 text-slate-400 truncate max-w-xs hidden lg:table-cell">${m.fields_of_study || '—'}</td>
              <td class="py-2.5 px-6 border-b border-gray-50 text-slate-500 hidden sm:table-cell">${countryName}</td>
              <td class="py-2.5 px-6 border-b border-gray-50 text-right">
                 <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-bold bg-slate-100 text-slate-600">
                    ${connCount}
                 </span>
              </td>
            </tr>`;
            }).join('');
            
             list.forEach(m => {
                if (m.avatar_url && !m.avatar_url.startsWith('http')) {
                    getAvatarUrl(m.avatar_url).then(u => {
                        const img = document.querySelector(`tr[onclick*="${m.id}"] img`);
                        if(img && u) img.src = u;
                    });
                }
            });
        }

        document.addEventListener('openProfile', e => {
            openProfileModal(state.profileById.get(e.detail), state.allCanonicalToDisplay, state.tagIndex);
        });

        function onFiltersChanged() {
            state.searchQuery = $('#searchInput').value;
            populateTagFilters();
            const list = getFiltered();
            renderTable(list);
            renderGraph(list);
        }

        (async function () {
            initSharedUI({ onLangSwitch: () => location.reload(), onSignOut: signOut });
            initProfileModal();

            document.addEventListener('click', e => {
                if (e.target.closest('#btnProfile') || e.target.closest('#userName')) {
                    window.location.href = 'profile.html';
                }
            });

            $$('[data-role]').forEach(b => b.onclick = e => {
                $$('[data-role]').forEach(x => { x.className = "px-3 py-1 text-[11px] font-bold rounded-full transition-all border border-gray-200 text-slate-500 hover:bg-gray-50"; });
                e.target.className = "px-3 py-1 text-[11px] font-bold rounded-full transition-all shadow-sm bg-slate-800 text-white";
                state.roleFilter = e.target.dataset.role; onFiltersChanged();
            });

            $$('th[data-sort]').forEach(th => {
                th.onclick = () => {
                    const key = th.dataset.sort;
                    if (state.sort.key === key) state.sort.dir = state.sort.dir === 'asc' ? 'desc' : 'asc';
                    else { state.sort.key = key; state.sort.dir = 'asc'; }
                    $$('th[data-sort]').forEach(h => { h.classList.remove('sort-asc', 'sort-desc', 'text-brand-600'); h.classList.add('text-slate-500'); });
                    th.classList.add(state.sort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
                    th.classList.remove('text-slate-500'); th.classList.add('text-brand-600');
                    onFiltersChanged();
                };
            });
            const initialTh = $(`th[data-sort="${state.sort.key}"]`);
            if(initialTh) {
                initialTh.classList.add(state.sort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
                initialTh.classList.remove('text-slate-500'); initialTh.classList.add('text-brand-600');
            }

            $('#groupByFilter').onchange = e => { state.groupBy = e.target.value; onFiltersChanged(); };
            $('#eventFilter').onchange = e => { state.eventFilterId = e.target.value; onFiltersChanged(); };
            $('#countryFilter').onchange = e => { state.countryFilterId = e.target.value; onFiltersChanged(); };
            $('#searchInput').oninput = debounce(onFiltersChanged);
            $('#clearFiltersBtn').onclick = () => { 
                state.searchQuery = ''; $('#searchInput').value = ''; 
                state.selectedTags.clear(); $('[data-role="all"]').click(); 
                $('#eventFilter').value = 'all'; state.eventFilterId = 'all';
                $('#countryFilter').value = 'all'; state.countryFilterId = 'all';
                $('#groupByFilter').value = 'affiliation'; state.groupBy = 'affiliation';
            };
            
            $('#viewToggleBtn').onclick = () => {
                const btn = $('#viewToggleBtn');
                const icon = btn.querySelector('i');
                
                if (state.viewMode === 'network') {
                    state.viewMode = 'bubble';
                    $('#viewModeText').innerText = "Switch to Network";
                    if (icon) icon.setAttribute('data-lucide', 'share-2');
                } else {
                    state.viewMode = 'network';
                    $('#viewModeText').innerText = "Switch to Bubbles";
                    if (icon) icon.setAttribute('data-lucide', 'layout-grid');
                }
                
                state.zoom = 1;
                state.panOffset = { x: 0, y: 0 };
                
                if (window.lucide) window.lucide.createIcons();
                
                const list = getFiltered();
                renderTable(list);
                renderGraph(list);
            };

            $('#resetViewBtn').onclick = () => {
                state.searchQuery = '';
                state.groupBy = 'affiliation';
                state.eventFilterId = 'all';
                state.countryFilterId = 'all';
                state.roleFilter = 'all';
                state.selectedTags.clear();
                state.sort = { key: "connections", dir: "desc" };

                $('#searchInput').value = '';
                $('#groupByFilter').value = 'affiliation';
                $('#eventFilter').value = 'all';
                $('#countryFilter').value = 'all';

                $$('[data-role]').forEach(x => { x.className = "px-3 py-1 text-[11px] font-bold rounded-full transition-all border border-gray-200 text-slate-500 hover:bg-gray-50"; });
                const allRoleBtn = $('[data-role="all"]');
                if(allRoleBtn) allRoleBtn.className = "px-3 py-1 text-[11px] font-bold rounded-full transition-all shadow-sm bg-slate-800 text-white";

                $$('th[data-sort]').forEach(h => { h.classList.remove('sort-asc', 'sort-desc', 'text-brand-600'); h.classList.add('text-slate-500'); });
                const defaultSortTh = $('th[data-sort="connections"]');
                if(defaultSortTh) {
                    defaultSortTh.classList.add('sort-desc');
                    defaultSortTh.classList.remove('text-slate-500');
                    defaultSortTh.classList.add('text-brand-600');
                }

                onFiltersChanged();
            };

            const cv = $('#network-container'); 
            let sx = 0, sy = 0;

            cv.onmousemove = e => {
                const rect = cv.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                if (!state.isDragging) { 
                    applyMagnification(mouseX, mouseY); 
                } else { 
                    state.panOffset.x = e.clientX - sx; 
                    state.panOffset.y = e.clientY - sy; 
                    updateTransform(); 
                }
            };

            cv.onmouseleave = () => {
                resetMagnification();
            };

            cv.onmousedown = e => { 
                if (e.target.closest('.network-node')) return;

                if (e.target.id === 'networkCanvas' || e.target === cv || e.target.closest('#networkNodes')) { 
                    state.isDragging = true; 
                    sx = e.clientX - state.panOffset.x; 
                    sy = e.clientY - state.panOffset.y; 
                    cv.style.cursor = 'grabbing'; 
                    resetMagnification();
                } 
            };
            
            window.onmouseup = () => { 
                state.isDragging = false; 
                cv.style.cursor = 'grab'; 
            };
            
            cv.onwheel = e => { 
                e.preventDefault(); 
                const s = e.deltaY > 0 ? 0.9 : 1.1; 
                state.zoom = clamp(state.zoom * s, 0.1, 5); 
                updateTransform(); 
                resetMagnification();
            };
            
            cv.ontouchstart = e => { 
                if (e.target.closest('.network-node')) return;
                if (e.target.id === 'networkCanvas' || e.target === cv) { 
                    state.isDragging = true; 
                    sx = e.touches[0].clientX - state.panOffset.x; 
                    sy = e.touches[0].clientY - state.panOffset.y; 
                } 
            };
            cv.ontouchmove = e => { 
                if (state.isDragging) { 
                    e.preventDefault(); 
                    state.panOffset.x = e.touches[0].clientX - sx; 
                    state.panOffset.y = e.touches[0].clientY - sy; 
                    updateTransform(); 
                } 
            };
            cv.ontouchend = () => { state.isDragging = false; };

            if (window.lucide) window.lucide.createIcons();

            const authPromise = initAuth({
                onAuthReady: () => {
                    renderHeader(authState, t, state.lang);
                    applyI18n(t, state.lang);
                },
                onAuthChange: () => renderHeader(authState, t, state.lang)
            });

            const dataPromise = loadNetworkData();

            await Promise.all([authPromise, dataPromise]);

            $('#loadingScreen').classList.add('opacity-0', 'pointer-events-none');

            if (!authState.session) {
                $('#signinGate').style.display = 'flex';
            } else {
                $('#signinGate').style.display = 'none';
            }
        })();
    </script>
</body>
</html>